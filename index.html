<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>WPT Filmstrip</title>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <link rel="stylesheet" href="mini-dark.min.css">
    <link rel="stylesheet" href="filmstrip.css">
</head>
<body>
    <div id="app">
        <div class="header">
            <h2>
                WPT Filmstrip </small><a v-if="waterfallUrl" :href="waterfallUrl" target="_blank">{{testLabel}}<span class="icon-link"></span></a> 
            </h2>
            <div class="testSelection">
                <input class="testUrl" v-model="testUrl" @change="loadData" placeholder="https://www.webpagetest.org/result/181122_MY_testid" />
                <button type="button" @click="loadData" class="primary">Load Test</button>

                <label>Step:</label>
                <select v-model="selectedStep" @change="updateTestData" :disabled="!availableSteps.length">
                    <option v-if="!availableSteps.length">Load a test first</option>
                    <option v-for="(name, index) in availableSteps" :value="index + 1">{{name}}</option>
                </select>
                <select v-model="showAnimation">
                    <option :value="true">Animation</option>
                    <option :value="false">Filmstrip</option>
                </select>
            </div>
        </div>

        <main>
            <div v-if="loading" class="spinner"></div>

            <p v-else-if="error" class="card error">{{ error }}</p>

            <div v-else-if="showAnimation && stepData" class="animationView">
                <filmstrip-animation :step-data="stepData" :timings="timings"></filmstrip-animation>
            </div>
            <div v-else-if="stepData" class="filmstripView">
                <filmstrip-view :step-data="stepData" :timings="timings"></filmstrip-view>
            </div>
        </main>

        <div class="collapse" v-if="timings.length">
            <input type="checkbox" id="collapse-metrics" aria-hidden="true">
            <label for="collapse-metrics" aria-hidden="true">Show Metrics</label>
            <div class="card fluid">
                <table class="horizontal">
                    <thead>
                        <tr>
                            <th v-for="timing in timings">{{ timing.name }}</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td v-for="timing in timings">{{ timing.value.toFixed(3) }}s</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
        <div class="framePreload">
            <img v-for="url in frameImages" :src="url" />
        </div>
    </div>
<script>

const metrics = {
    "LastInteractive": "Interactive",
    "FirstInteractive": "First Interactive",
    "SpeedIndex": "Speed Index",
    "TTFB": "Time to First Byte",
    "TimeToInteractive": "Time to Interactive",
    "domComplete": "DOM  Complete",
    "domContentLoadedEventStart": "DOM Content Loaded",
    "domInteractive": "DOM Interactive",
    "firstContentfulPaint": "First Contentful Paint",
    "firstMeaningfulPaint": "First Meaningful Paint",
    "fullyLoaded": "Fully Loaded",
    "lastVisualChange": "Last Visual Change",
    "docTime": "Load Time (onload)",
    "render": "Start Render",
    "visualComplete": "Visually Complete",
    "visualComplete85": "85% Visually Complete",
    "visualComplete90": "90% Visually Complete",
    "visualComplete95": "95% Visually Complete",
    "visualComplete99": "99% Visually Complete",
};

const highlightMetrics = {
    "docTime": true,
    "FirstInteractive": true,
    "LastInteractive": true,
    "fullyLoaded": true
}
Vue.component('filmstrip-animation', {
    template: `
        <div class="animationView">
            <div class="customization">
                <label><input v-model="showTimings" type="checkbox" /> Show metrics</label>
                <label>Slowdown factor:</label>
                <input v-model="slowdownFactor" type="number" min="1" max="50" step="1" />
                <br>
                <span><kbd>Left</kbd> <kbd>Right</kbd> Change frame</span>
                <span><kbd>m</kbd> Toggle metrics</span>
                <span><kbd>r</kbd> Reset animation</span>
                <span><kbd>Space</kbd> Resume/Pause</span>
            </div>
            <div class="controls">
                <button @click="previousFrame" :disabled="this.time < this.interval">-0.1s</button>
                <button v-if="isStarted" @click="pause">Pause</button>
                <button v-else-if="paused && time > 0" @click="resume">Resume</button>
                <button v-else @click="start">Start</button>
                <button @click="nextFrame" :disabled="this.time > this.end">+0.1s</button>
            </div>
            <div v-if="frame" class="thumbnail" :class="{hasMetric: !!frame.metrics.length}">
                <img :src="frame.url" :style="{width: width + 'px'}" />
                <span class="time">{{ (time / 1000).toFixed(1) }}s</span>
                <ul v-if="showTimings && frame.metrics.length" class="metrics" :style="{'max-width': width + 'px'}">
                    <li v-for="metric in frame.metrics"
                        :class="{custom: metric.type != 'metric', highlight: metric.highlight}">{{ metric.name }} ({{metric.value.toFixed(1) + "s"}})</li>
                </ul>
            </div>
        </div>
    `,
    props: [
        'stepData',
        'timings'
    ],
    watch: { 
        stepData: function() { 
            this.reset();
        }
    },
    data: function() { return {
        frame: null,
        time: 0,
        end: 0,
        slowdownFactor: 4,
        showTimings: false,
        width: 400,
        paused: false,
        keydownHandler: null,
        interval: 100,
        filmstrip: []
    }},
    created: function() {
        this.reset();
        this.keydownHandler = document.addEventListener("keydown", (event) => {
            if (event.key == "ArrowLeft") {
                this.previousFrame();
            } else if (event.key == "ArrowRight") {
                this.nextFrame();
            } else if (event.key == " ") {
                if (this.paused) {
                    this.resume();
                } else {
                    this.pause();
                }
            } else if (event.key == "m") {
                this.showTimings = !this.showTimings;
            } else if (event.key == "r") {
                this.reset();
            } else {
                return;
            }
            e.preventDefault();
            e.stopPropagation();
        });
    },
    beforeDestroy: function() {
        if (this.keydownHandler) {
            window.removeEventListener("keydown", this.keydownHandler);
            this.keydownHandler = null;
        }
    },
    computed: {
        isStarted: function() {
            return this.time <= this.end && !this.paused;
        }
    },
    methods: {
        start: function() {
            this.reset();
            this.resume();
        },
        reset: function() {
            if (!this.stepData) {
                return;
            }
            this.filmstrip = createFilmstrip(this.stepData, this.interval, this.timings);
            this.time = 0;
            this.paused = true;
            this.end = this.filmstrip[this.filmstrip.length - 1].time;
            this.frame = this.filmstrip[0];
        },
        pause: function() {
            this.paused = true;
        },
        resume: function() {
            this.paused = false;
            this.animate();
        },
        animate: function() {
            if (!this.isStarted) {
                return;
            }
            if (this.time == 0) {
                this.frame = this.filmstrip[0];
            }
            const shouldWait = this.frame.time == this.time && this.frame.metrics.some(metric => metric.highlight) && this.showTimings;
            const waitFactor = shouldWait ? 5 : 1;
            setTimeout(() => {
                this.nextFrame();
                this.animate();
            }, this.interval * this.slowdownFactor * waitFactor);
        },
        previousFrame: function() {
            if (this.time >= this.interval) {
                this.updateFrame(-this.interval);
            }
        },
        nextFrame: function() {
            if (this.time <= this.end) {
                this.updateFrame(this.interval);
            }
        },
        updateFrame: function(interval) {
            this.time += interval;
            this.frame = this.filmstrip.find(frame => frame.time == this.time) || this.frame;
        }
    }
});

Vue.component('fimstrip-view', {
    template: `
        <div class="customization">
            <label><input v-model="showTimings" type="checkbox" /> Show metrics</label>
            <label>Thumbnail width:</label>
            <input v-model="thumbnailWidth" type="number" min="50" max="400" step="50" @change="saveState" />
            <label>Columns:</label>
            <input v-model="columns" type="number" min="0" :max="filmstrip.length" @change="updateFilmstrip" />
            <label>Interval (ms):</label>
            <input v-model="interval" type="number" min="100" :max="5000" step="100" @change="updateFilmstrip" />
        </div>
        <div class="stage" :style="{'grid-template-columns': 'repeat(' + columns + ', max-content)'}">
            <div v-for="thumbnail in this.filmstrip" @click="showTimings = !showTimings"
                class="thumbnail" :class="{hasChange: thumbnail.hasChange}">
                <img :src="thumbnail.url" :style="{width: thumbnailWidth + 'px'}" :title="thumbnail.visuallyComplete + '% Visual Progress'" />
                <span class="time">{{ thumbnail.timeFormatted }}</span>
                <ul v-if="!!thumbnail.metrics.length && showTimings" class="metrics" :style="{'max-width': thumbnailWidth + 'px'}">
                    <li v-for="metric in thumbnail.metrics"
                        :class="{custom: metric.type != 'metric', highlight: metric.highlight}">{{ metric.name }} ({{metric.value.toFixed(1) + "s"}})</li>
                </ul>
            </div>
        </div>
    `,
    props: [
        "stepData",
        "timings"
    ],
    data: function() { return {
        showTimings: false,
        thumbnailWidth: 150,
        interval: 200,
        columns: 9,
        interval: 500,
        filmstrip: []
    }},
    watch: { 
        stepData: function() { 
            this.reset();
        }
    },
    created: function() {
        this.loadState();
        this.updateFilmstrip();
    },
    methods: {
        updateFilmstrip: function() {
            if (!this.stepData) {
                return;
            }
            this.filmstrip = createFilmstrip(this.stepData, this.interval, this.timings)
            this.saveState();
        },
        loadState: function() {
            this.columns = Number(localStorage.getItem('filmstripView.columns')) || this.columns;
            this.interval = Number(localStorage.getItem('filmstripView.interval')) || this.interval;
            this.interval = Number(localStorage.getItem('filmstripView.thumbnailWidth')) || this.thumbnailWidth;
        },
        saveState: function() {
            localStorage.setItem('filmstripView.columns', this.columns);
            localStorage.setItem('filmstripView.interval', this.interval);
            localStorage.setItem('filmstripView.thumbnailWidth', this.thumbnailWidth);
        }
    }
});

var app = new Vue({
    el: '#app',
    data: {
        wptUrl: "",
        selectedRun: "1",
        selectedStep: 1,
        availableSteps: [],
        testId: "",
        testData: null,
        error: null,
        stepData: null,
        timings: [],
        testLabel: "",
        loading: false,
        testUrl: "",
        showAnimation: true,
        frameImages: []
    },
    created: function () {
        this.loadState();
        if (this.testUrl) {
            this.loadData();
        }
    },
    computed: {
        waterfallUrl: function() {
            if (!this.testData || !this.testId) {
                return null;
            }
            return `${this.wptUrl}/result/${this.testId}/${this.selectedRun}/details/#waterfall_view_step${this.selectedStep}`;
        },
        videoUrl: function() {
            if (!this.testData || !this.testId) {
                return null;
            }
            return `${this.wptUrl}/video/create.php?tests=${this.testId}-r:${this.selectedRun}-c:0-s:${this.selectedStep}&id=${this.testId}${this.selectedRun}${this.selectedStep}`;
        }
    },
    methods: {
        loadData: function() {
            [this.wptUrl, this.testId, this.selectedStep] = parseTestUrl(this.testUrl);
            this.loading = true;
            fetchData(this.wptUrl, this.testId)
                .then(response => {
                    this.testData = response.data;
                    this.updateTestData();
                })
                .catch(error => this.error = "Failed to load data: " + error)
                .then(() => this.loading = false);
        },
        updateTestData: function() {
            if (!(((((this.testData || {}).runs || {})[this.selectedRun] || {}).firstView || {}).steps || []).length) {
                return;
            }
            const runData = this.testData.runs[this.selectedRun].firstView;
            this.availableSteps = runData.steps.map(step => step.eventName || `Step ${step.id}`)
            this.selectedStep = Math.min(this.selectedStep, runData.numSteps);
            this.testLabel = this.testData.label + ",  " + (this.availableSteps[this.selectedStep - 1] || "");
            this.stepData = runData.steps[this.selectedStep - 1];
            if (!this.stepData) {
                throw "Invalid test data";
            }
            this.timings = createTimings(this.stepData);
            this.frameImages = this.stepData.videoFrames.map(frame => frame.image);
            this.saveState();
        },
        loadState: function() {
            this.testUrl = localStorage.getItem('loadedTestUrl') || this.testUrl;
        },
        saveState: function() {
            localStorage.setItem('loadedTestUrl', this.testUrl);
        }
    }
})

function parseTestUrl(testUrl) {
    const [protocol, url] = testUrl.split("://", 2);
    const parts = url.split("/");
    const testId = parts[1] == "result" ? parts[2] : "";
    const stepMatches = /_step(\d+)$/.exec(parts[parts.length - 1]);
    const step = stepMatches ? stepMatches[1] : 1;
    return [protocol + "://" + parts[0], testId, step];
}

function createTimings(stepData) {
    const userTimings = Object.keys(stepData.userTimes || {}).map(name => ({
        name: name,
        type: "user",
        value: Number(stepData.userTimes[name]) / 1000,
        highlight: false
    }));
    const heroTimings = Object.keys(stepData.heroElementTimes || {}).map(name => ({
        name: "Hero: " + name,
        type: "hero",
        value: Number(stepData.heroElementTimes[name]) / 1000,
        highlight: false
    }));
    const timings = Object.keys(metrics)
        .filter(metric => stepData[metric] != undefined)
        .map(metric => ({
           name: metrics[metric],
           type: "metric",
           value: Number(stepData[metric]) / 1000,
           highlight: !!highlightMetrics[metric]
        }));
    return [...timings, ...userTimings, ...heroTimings].sort((a, b) => a.value - b.value);
}

function createFilmstrip (stepData, interval, timings) {
    const end = Math.max(...timings.map(t => t.value)) * 1000;
    const filmstrip = [];
    let lastVideoFrame = null;
    for (let time = 0; time < end + interval; time += interval) {
        const videoFrame = findFrame(stepData.videoFrames, time);
        filmstrip.push({
            time: time,
            timeFormatted: (time / 1000.0).toFixed(1) + "s",
            visuallyComplete: videoFrame.VisuallyComplete,
            url: videoFrame.image,
            frameTime: videoFrame.time,
            hasChange: !lastVideoFrame || lastVideoFrame.time != videoFrame.time,
            metrics: findTimings(timings, time - interval, time)
        });
        lastVideoFrame = videoFrame;
    }
    return filmstrip;
}

function fetchData(wptUrl, wptTestId) {
    const wptParams = "average=0&median=0&standard=0&requests=0&console=0"
    return fetch(`${wptUrl}/result/${wptTestId}/?f=json&${wptParams}`)
        .then(response => response.json())
        .then(testData => {
            if (!testData || testData.statusCode != 200) {
                throw (testData || {}).statusText || "Invalid response";
            }
            return testData;
        })
}

function findFrame(videoFrames, time) {
    let frame = videoFrames[0];
    for (let currentFrame of videoFrames) {
        if (time >= currentFrame.time) {
            frame = currentFrame;
        } else {
            break;
        }
    }
    return frame;
}

function findTimings(timings, start, end) {
    return timings.filter(timing => timing.value > start / 1000 && timing.value <= end / 1000);
}

</script>
</body>
</html>