<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Filmstrip</title>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <link rel="stylesheet" href="mini-dark.min.css">
    <style>
        :root {
            --fore-color: #e2e2e2;
            --a-link-color: #1976d2;
            --input-border-color: #212121;
            --input-fore-color: #e2e2e2;
            --input-back-color: #212121;
            --card-border-color: #212121;
        }

        h2 {
            margin: 0;
            padding: 20px;
        }

        .testSelection {
            padding: 0 20px 20px 20px;
            display: flex;
            align-items: center;
        }

        .testSelection .testUrl {
            margin-right: 0;
            margin-left: 0;
            border-right: 0;
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
            flex-grow: 1;
        }

        .testSelection .primary {
            margin-left: 0;
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
        }

        main {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 70vh;
            position: relative;
        }

        .customization {
            position: absolute;
            right: 0;
            display: flex;
            flex-direction: column;
            padding-right: 20px;
        }

        .filmstripView  {
            width: 100%;
        }

        .filmstripView .stage {
            display: flex;
            margin: 20px 0;
            display: grid;
            overflow-x: auto;
            grid-row-gap: 30px;
        }

        .spinner {
            height: 5rem;
            width: 5rem;
        }

        .animationView {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 150px;
        }

        .animationView .thumbnail img {
            border-radius: var(--universal-border-radius);
        }

        .animationView .thumbnail .metrics {
            display: block;
            position: absolute;
            height: 50vh;
            right: calc(50% + 220px);
            padding: 0 20px;
            top: 200px;
        }

        .animationView .thumbnail .metrics li {
            font-size: 16px;
        }

        .thumbnail {
            /*background: black;*/
            cursor: pointer;
            color: white;
        }

        .thumbnail .time {
            display: block;
            text-align: center;
            padding-bottom: 5px;
        }

        .thumbnail img {
            text-align: center;
            height: auto;
            margin: 10px;
        }

        .thumbnail.hasChange .time {
            font-weight: bold;
        }

        .thumbnail .metrics {
            list-style: none outside;
        }

        .thumbnail .metrics li {
            line-height: 1.2em;
            font-size: 12px;
        }
        
        .thumbnail .metrics .custom {
            font-style: italic;
        }

        .thumbnail .metrics .highlight {
            font-weight: bold;
            color: white;
        }

        .framePreload {
            display: none;
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="header">
            <h2>
                WPT Filmstrip </small><a v-if="waterfallUrl" :href="waterfallUrl" target="_blank">{{testLabel}}<span class="icon-link"></span></a> 
            </h2>
            <div class="testSelection">
                <input class="testUrl" v-model="testUrl" @change="loadData" placeholder="https://www.webpagetest.org/result/181122_MY_testid" />
                <button type="button" @click="loadData" class="primary">Load Test</button>

                <label>Step:</label>
                <select v-model="selectedStep" @change="updateFilmstrip">
                    <option v-for="(name, index) in availableSteps" :value="index + 1">{{name}}</option>
                </select>
                <select v-model="showAnimation">
                    <option :value="true">Animation</option>
                    <option :value="false">Filmstrip</option>
                </select>
            </div>
        </div>

        <main>
            <div v-if="loading" class="spinner"></div>

            <div v-else-if="showAnimation && filmstrip.length" class="animationView">
                <div class="customization">
                    <label><input v-model="showTimings" type="checkbox" /> Show metrics</label>
                </div>
                <filmstrip-animation :filmstrip="filmstrip" :show-timings="showTimings"></filmstrip-animation>
            </div>
            
            <div v-else class="filmstripView">
                <div class="customization">
                    <label><input v-model="showTimings" type="checkbox" /> Show metrics</label>
                    <label>Thumbnail width:</label>
                    <input v-model="thumbnailWidth" type="number" min="50" max="400" step="50" />
                    <label>Columns:</label>
                    <input v-model="columns" type="number" min="0" :max="filmstrip.length" />
                    <label>Interval (ms):</label>
                    <input v-model="interval" type="number" min="100" :max="5000" step="100" @input="updateFilmstrip"/>
                </div>
                <p v-if="error" class="card error">{{ error }}</p>
                <div v-else-if="filmstrip.length" class="stage" :style="{'grid-template-columns': 'repeat(' + columns + ', max-content)'}">
                    <div v-for="thumbnail in this.filmstrip" @click="showTimings = !showTimings"
                        class="thumbnail" :class="{hasChange: thumbnail.hasChange}">
                        <img :src="thumbnail.url" :style="{width: thumbnailWidth + 'px'}" :title="thumbnail.visuallyComplete + '% Visual Progress'" />
                        <span class="time">{{ thumbnail.timeFormatted }}</span>
                        <ul v-if="!!thumbnail.metrics.length && showTimings" class="metrics" :style="{'max-width': thumbnailWidth + 'px'}">
                            <li v-for="metric in thumbnail.metrics"
                                :class="{custom: metric.type != 'metric', highlight: metric.highlight}">{{ metric.name }} ({{metric.value.toFixed(1) + "s"}})</li>
                        </ul>
                    </div>
                </div>
            </div>
        </main>

        <!-- <div class="card fluid">
            <timeline></timeline>
        </div> -->

        <div class="card fluid" v-if="showTimings && timings.length">
            <table class="horizontal">
                <caption>Metrics</caption>
                <thead>
                    <tr>
                        <th v-for="timing in timings">{{ timing.name }}</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td v-for="timing in timings">{{ timing.value.toFixed(3) }}s</td>
                    </tr>
                </tbody>
            </table>
        </div>
        <div class="framePreload">
            <img v-for="url in frameImages" :src="url" />
        </div>
    </div>
<script>

const metrics = {
    "LastInteractive": "Interactive",
    "FirstInteractive": "First Interactive",
    "SpeedIndex": "Speed Index",
    "TTFB": "Time to First Byte",
    "TimeToInteractive": "Time to Interactive",
    "domComplete": "DOM  Complete",
    "domContentLoadedEventStart": "DOM Content Loaded",
    "domInteractive": "DOM Interactive",
    "firstContentfulPaint": "First Contentful Paint",
    "firstMeaningfulPaint": "First Meaningful Paint",
    "fullyLoaded": "Fully Loaded",
    "lastVisualChange": "Last Visual Change",
    "docTime": "Load Time (onload)",
    "render": "Start Render",
    "visualComplete": "Visually Complete",
    "visualComplete85": "85% Visually Complete",
    "visualComplete90": "90% Visually Complete",
    "visualComplete95": "95% Visually Complete",
    "visualComplete99": "99% Visually Complete",
//    "fullyLoadedCPUms": "CPU Busy Time"
};

const highlightMetrics = {
    "docTime": true,
    "FirstInteractive": true,
    "LastInteractive": true
}
Vue.component('filmstrip-animation', {
    template: `
        <div class="animationView">
            <button v-if="isStarted" @click="pause">Pause</button>
            <button v-else-if="paused" @click="resume">Resume</button>
            <button v-else @click="start">Start</button>
            <div class="thumbnail">
                <img :src="frame.url" :style="{width: width + 'px'}" />
                <span class="time">{{ (time / 1000).toFixed(1) }}s</span>
                <ul v-if="showTimings && frame.metrics.length" class="metrics" :style="{'max-width': width + 'px'}">
                    <li v-for="metric in frame.metrics"
                        :class="{custom: metric.type != 'metric', highlight: metric.highlight}">{{ metric.name }} ({{metric.value.toFixed(1) + "s"}})</li>
                </ul>
            </div>
        </div>
    `,
    props: [
        'filmstrip',
        'showTimings'
    ],
    data: function() { return {
        frame: this.filmstrip[0],
        time: 0,
        end: 0,
        slowdownFactor: 3,
        width: 400,
        paused: false
    }},
    computed: {
        isStarted: function() {
            return this.time < this.end && !this.paused;
        }
    },
    methods: {
        start: function() {
            this.time = 0;
            this.paused = false;
            this.end = this.filmstrip[this.filmstrip.length - 1].time;
            this.changeFrame();
        },
        pause: function() {
            this.paused = true;
        },
        resume: function() {
            this.paused = false;
            this.changeFrame();
        },
        changeFrame: function() {
            const increment = 100;
            if (!this.isStarted) {
                return;
            }
            if (this.time == 0) {
                this.frame = this.filmstrip[0];
            }
            setTimeout(() => {
                this.time += increment;
                this.frame = this.filmstrip.find(frame => frame.time == this.time) || this.frame;
                this.changeFrame();
            }, increment * this.slowdownFactor);
        }
    }
});

Vue.component('timeline', {
    template: `
        
    `,
    props: [
        'filmstrip'
    ],
    data: function() { return {

    }},
    methods: {

    }
});

var app = new Vue({
    el: '#app',
    data: {
        wptUrl: "",
        selectedRun: "1",
        selectedStep: 1,
        availableSteps: [],
        testId: "",
        testData: null,
        error: null,
        filmstrip: [],
        timings: [],
        showTimings: false,
        interval: 500,
        columns: 9,
        testLabel: "",
        loading: false,
        thumbnailWidth: 150,
        testUrl: "",
        showAnimation: true,
        frameImages: []
    },
    created: function () {
        this.loadState();
        if (this.testUrl) {
            this.loadData();
        }
    },
    computed: {
        waterfallUrl: function() {
            if (!this.testData || !this.testId) {
                return null;
            }
            return `${this.wptUrl}/result/${this.testId}/${this.selectedRun}/details/#waterfall_view_step${this.selectedStep}`;
        },
        videoUrl: function() {
            if (!this.testData || !this.testId) {
                return null;
            }
            return `${this.wptUrl}/video/create.php?tests=${this.testId}-r:${this.selectedRun}-c:0-s:${this.selectedStep}&id=${this.testId}${this.selectedRun}${this.selectedStep}`;
        }
    },
    methods: {
        loadData: function() {
            [this.wptUrl, this.testId, this.selectedStep] = parseTestUrl(this.testUrl);
            this.loading = true;
            fetchData(this.wptUrl, this.testId)
                .then(response => {
                    this.testData = response.data;
                    this.updateFilmstrip();
                })
                .catch(error => this.error = "Failed to load data: " + error)
                .then(() => this.loading = false);
        },
        updateFilmstrip: function() {
            if (!(((((this.testData || {}).runs || {})[this.selectedRun] || {}).firstView || {}).steps || []).length) {
                return;
            }
            const runData = this.testData.runs[this.selectedRun].firstView;
            this.availableSteps = runData.steps.map(step => step.eventName || `Step ${step.id}`)
            this.selectedStep = Math.min(this.selectedStep, runData.numSteps);
            this.testLabel = this.testData.label + ",  " + (this.availableSteps[this.selectedStep - 1] || "");
            const stepData = runData.steps[this.selectedStep - 1];
            if (!stepData) {
                throw "Invalid test data";
            }
            this.timings = createTimings(stepData);
            this.filmstrip = createFilmstrip(stepData, Number(this.interval), this.timings);
            this.frameImages = stepData.videoFrames.map(frame => frame.image);
            console.log(this.filmstrip);
            this.columns = Math.min(this.columns || 9999, this.filmstrip.length);
            this.saveState();
        },
        loadState: function() {
            this.testUrl = localStorage.getItem('loadedTestUrl') || this.testUrl;
            this.columns = Number(localStorage.getItem('columns')) || this.columns;
            this.interval = Number(localStorage.getItem('interval')) || this.interval;
        },
        saveState: function() {
            localStorage.setItem('loadedTestUrl', this.testUrl);
            localStorage.setItem('columns', this.columns);
            localStorage.setItem('interval', this.interval);
        }
    }
})

function parseTestUrl(testUrl) {
    const [protocol, url] = testUrl.split("://", 2);
    const parts = url.split("/");
    const testId = parts[1] == "result" ? parts[2] : "";
    const stepMatches = /_step(\d+)$/.exec(parts[parts.length - 1]);
    const step = stepMatches ? stepMatches[1] : 1;
    return [protocol + "://" + parts[0], testId, step];
}

function createTimings(stepData) {
    const userTimings = Object.keys(stepData.userTimes || {}).map(name => ({
        name: name,
        type: "user",
        value: Number(stepData.userTimes[name]) / 1000,
        highlight: false
    }));
    const heroTimings = Object.keys(stepData.heroElementTimes || {}).map(name => ({
        name: "Hero: " + name,
        type: "hero",
        value: Number(stepData.heroElementTimes[name]) / 1000,
        highlight: false
    }));
    const timings = Object.keys(metrics)
        .filter(metric => stepData[metric] != undefined)
        .map(metric => ({
           name: metrics[metric],
           type: "metric",
           value: Number(stepData[metric]) / 1000,
           highlight: !!highlightMetrics[metric]
        }));
    return [...timings, ...userTimings, ...heroTimings].sort((a, b) => a.value - b.value);
}

function createFilmstrip (stepData, interval, timings) {
    const end = Math.max(...timings.map(t => t.value)) * 1000;
    const filmstrip = [];
    let lastVideoFrame = null;
    for (let time = 0; time < end + interval; time += interval) {
        const videoFrame = findFrame(stepData.videoFrames, time);
        filmstrip.push({
            time: time,
            timeFormatted: (time / 1000.0).toFixed(1) + "s",
            visuallyComplete: videoFrame.VisuallyComplete,
            url: videoFrame.image,
            frameTime: videoFrame.time,
            hasChange: !lastVideoFrame || lastVideoFrame.time != videoFrame.time,
            metrics: findTimings(timings, time - interval, time)
        });
        lastVideoFrame = videoFrame;
    }
    return filmstrip;
}

function fetchData(wptUrl, wptTestId) {
    const wptParams = "average=0&median=0&standard=0&requests=0&console=0"
    return fetch(`${wptUrl}/result/${wptTestId}/?f=json&${wptParams}`)
        .then(response => response.json())
        .then(testData => {
            if (!testData || testData.statusCode != 200) {
                throw (testData || {}).statusText || "Invalid response";
            }
            return testData;
        })
}

function findFrame(videoFrames, time) {
    let frame = videoFrames[0];
    for (let currentFrame of videoFrames) {
        if (time >= currentFrame.time) {
            frame = currentFrame;
        } else {
            break;
        }
    }
    return frame;
}

function findTimings(timings, start, end) {
    return timings.filter(timing => timing.value > start / 1000 && timing.value <= end / 1000);
}

</script>
</body>
</html>